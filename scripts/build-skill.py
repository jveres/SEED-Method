#!/usr/bin/env python3
"""Build (or verify) the SEED Method skill for skills.sh.

Outputs:
- skills/seed/SKILL.md: skills.sh-compatible skill entrypoint.
- skills/seed/PLAYBOOK.md: the full playbook text (generated).

Source:
- dist/AGENTS.md (generated by scripts/build-dist.py)

We build the skill from the dist file so the skill stays consistent with the
single-file distribution users copy into their repos.

This keeps the skills.sh page readable by keeping SKILL.md short and placing the
full playbook text in PLAYBOOK.md.
"""

from __future__ import annotations

import argparse
import sys
from pathlib import Path

ROOT = Path(__file__).resolve().parent.parent

DEFAULT_DIST_PATH = ROOT / "dist" / "AGENTS.md"
DEFAULT_OUT_PATH = ROOT / "skills" / "seed" / "SKILL.md"

FRONTMATTER = """---
name: seed
description: >-
  The SEED Method playbook for agent-driven software projects
  (SEED -> Bootstrap -> Build -> Prove -> Worklog -> Adapt -> Release)
---

"""

INTRO = """# The SEED Method

Use this skill as an on-demand process playbook when you are working in a repo
that follows the SEED Method.

## What to do when invoked

1. Read `PLAYBOOK.md` in this skill directory.
2. Apply the playbook rules to the current task.
3. If the repo contains its own `AGENTS.md`, treat the repo file as the
   authoritative, repo-specific source of truth.

## Quick install

```bash
npx skills add jveres/The-SEED-Method@seed
```

Skill page: https://skills.sh/jveres/The-SEED-Method/seed
Full playbook (readable): https://github.com/jveres/The-SEED-Method/blob/main/skills/seed/PLAYBOOK.md
Single-file distribution build: https://github.com/jveres/The-SEED-Method/blob/main/dist/AGENTS.md

"""


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser()
    p.add_argument(
        "--dist",
        default=str(DEFAULT_DIST_PATH),
        help="Path to dist/AGENTS.md (default: dist/AGENTS.md)",
    )
    p.add_argument(
        "--out",
        default=str(DEFAULT_OUT_PATH),
        help="Output path (default: skills/seed/SKILL.md)",
    )
    p.add_argument(
        "--check",
        action="store_true",
        help="Check that the output is up to date; do not write",
    )
    return p.parse_args()


def build_skill_text() -> str:
    return (FRONTMATTER + INTRO).replace("\r\n", "\n")


def build_playbook_text(dist_text: str) -> str:
    header = (
        "<!-- Generated file: skills/seed/PLAYBOOK.md. "        "Source: dist/AGENTS.md -->\n\n"
    )

    text = dist_text.strip()
    if text.startswith("<!-- Generated file: dist/AGENTS.md"):
        # Drop the dist build header to keep the skill playbook cleaner.
        lines = text.splitlines()
        text = "\n".join(lines[1:]).lstrip()

    return (header + text + "\n").replace("\r\n", "\n")


def main() -> None:
    args = parse_args()

    dist_path = Path(args.dist)
    out_path = Path(args.out)

    if not dist_path.exists():
        print(f"Missing {dist_path}. Run: ./scripts/build-dist.py")
        sys.exit(1)

    dist_text = dist_path.read_text(encoding="utf-8")

    playbook_path = out_path.parent / "PLAYBOOK.md"

    expected_skill = build_skill_text()
    expected_playbook = build_playbook_text(dist_text)

    if args.check:
        missing = [p for p in (out_path, playbook_path) if not p.exists()]
        if missing:
            for p in missing:
                print(f"Missing {p}. Run: ./scripts/build-skill.py")
            sys.exit(1)

        actual_skill = out_path.read_text(encoding="utf-8")
        actual_playbook = playbook_path.read_text(encoding="utf-8")

        if actual_skill != expected_skill or actual_playbook != expected_playbook:
            print(
                f"Out of date: {out_path.parent}. Run: ./scripts/build-skill.py"
            )
            sys.exit(1)

        print(f"OK: {out_path} and {playbook_path} are up to date")
        return

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(expected_skill, encoding="utf-8")
    playbook_path.write_text(expected_playbook, encoding="utf-8")

    print(f"Wrote {out_path.relative_to(ROOT)} ({out_path.stat().st_size} bytes)")
    print(
        f"Wrote {playbook_path.relative_to(ROOT)} ({playbook_path.stat().st_size} bytes)"
    )


if __name__ == "__main__":
    main()
